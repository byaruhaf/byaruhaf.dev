<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Franklin Byaruhanga</title><description>Just another blog about programming - iOS, macOS, Swift</description><link>https://byaruhaf.dev</link><language>en</language><lastBuildDate>Sat, 10 Dec 2022 10:03:06 +0300</lastBuildDate><pubDate>Sat, 10 Dec 2022 10:03:06 +0300</pubDate><ttl>250</ttl><atom:link href="https://byaruhaf.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://byaruhaf.dev/articles/swift_key_pathsmd</guid><title>Swift key paths</title><description></description><link>https://byaruhaf.dev/articles/swift_key_pathsmd</link><pubDate>Fri, 9 Dec 2022 12:35:41 +0300</pubDate><content:encoded><![CDATA[<h1>Swift key paths</h1><h2>what are Swift key paths</h2><p>Swift key paths are like shortcuts for getting to a specific part of something. Imagine you have a big box full of toys, and you want to find your favorite toy car. Instead of digging through the whole box, you can use a key path to quickly find it. The key path would be like a map that tells you exactly where the toy car is in the box, so you don't have to look through everything to find it. Swift key paths work the same way, they help you quickly find something specific in a big collection of information.</p><h2>what are the benefits of swift keypaths</h2><p>There are several benefits to using swift key paths:</p><ul><li>They provide a concise and readable way to access properties of objects. Instead of using long and complex chains of dot notation to access a property, you can use a simple key path that clearly shows the path to the property.</li><li>They allow you to easily access properties of nested objects. With key paths, you can easily access properties that are several levels deep in a data structure, without having to write long and complex chains of dot notation.</li><li>They make your code more flexible and reusable. With key paths, you can define a property access once, and then use it to access that property on any object that has that property. This means you can write code that is more generic and can be used with different objects, without having to write custom accessors for each object.</li><li>They allow you to easily update properties of objects. With key paths, you can use the assignment operator (=) to update a property, without having to write custom setters or accessors. This makes it easy to update properties of objects, and can improve the performance of your code.</li></ul><h2>how to use swift key paths</h2><p>To use swift key paths in Swift, you first need to create a key path by using the  (backslash) operator. For example, let's say you have a model object called "Person" with properties for "name" and "age". To create a key path for the "name" property, you would use this code:</p><pre><code><span class="swift-keyword">let</span> nameKeyPath = \<span class="swift-type">Person</span>.<span class="swift-property">name</span>
</code></pre><p>Once you have your key path, you can use it to access the property of an object. For example, let's say you have a "Person" object called "john" with a name of "John Doe" and an age of 30. You can use the key path to access the "name" property like this:</p><pre><code><span class="swift-keyword">let</span> johnsName = john[keyPath: nameKeyPath] <span class="swift-comment">// this would return "John Doe"</span>
</code></pre><p>You can also use key paths to access properties of nested objects. For example, let's say the "Person" object also has a property called "address" which is an object with properties for "street", "city", and "zip". You can create a key path for the "street" property like this:</p><pre><code><span class="swift-keyword">let</span> streetKeyPath = \<span class="swift-type">Person</span>.<span class="swift-property">address</span>.<span class="swift-property">street</span>
</code></pre><p>And then use it to access the property like this:</p><pre><code><span class="swift-keyword">let</span> johnsStreet = john[keyPath: streetKeyPath] <span class="swift-comment">// this would return the street address of John's address property</span>
</code></pre><p>Swift key paths are a useful tool for quickly accessing specific properties of objects, especially when dealing with complex data structures.</p><p>Overall, swift key paths provide a powerful and flexible way to access and update properties of objects, and can help you write cleaner and more efficient code.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://byaruhaf.dev/articles/SPM_Multiplatform_App</guid><title>Adding a swift package to a Multiplatform App on Xcode 12</title><description>A description of my first post.</description><link>https://byaruhaf.dev/articles/SPM_Multiplatform_App</link><pubDate>Sun, 28 Nov 2021 15:28:00 +0300</pubDate><content:encoded><![CDATA[<h1>Adding a swift package to a Multiplatform App on Xcode 12</h1><p>Over the weekend i run in to this problem trying to add Swift Package to both targets of a Multiplatform app. Below I will demonstrate the problem and one solution to the issue.</p><p>Open Xcode 12 or newer and hit ⌘⇧N to create a new project. Navigate to the new “Multiplatform” section, select App, and press Next. Then save your project as usual.</p><img src="Screenshot%202020-11-24%20at%2000.22.26.png"/><p>Try to add a <a href="https://github.com/byaruhaf/package-name">swift package</a> to this app, you will need to select Target either iOS or macOS but not both. The Target selected will be the only one able to access the swift package.</p><img src="Screenshot%202020-11-24%20at%2000.23.49.png"/><p>Trying to add the swift package again to another target results in the error below.</p><img src="Screenshot%202020-11-24%20at%2000.23.13.png"/><p>The package can either be added to iOS or macOS but not both, this is where I got stuck.</p><p>One solution I found was to , Use the General pane of the project editor to specify the frameworks and libraries for the target I didn’t select when adding the swift package.<br><img src="Screenshot%202020-11-24%20at%2002.17.23.png"/></p><p>In my case I selected the macOS Target, then from the General pane. Under the Frameworks, Libraries and Embedded Content tap the plus + button, select the package and press Add.</p><img src="Screenshot%202020-11-24%20at%2002.15.16.png"/><p>The swift package can now be used by the macOS Target.</p><img src="Screenshot%202020-11-24%20at%2002.15.33.png"/><p>This workflow is not ideal in my opinion, so I summited a feedback with the Xcode Team.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://byaruhaf.dev/articles/Swift_Language_Version</guid><title>What is the “Swift Language Version” Xcode setting for?</title><description>A description of my first post.</description><link>https://byaruhaf.dev/articles/Swift_Language_Version</link><pubDate>Sat, 28 Nov 2020 15:28:00 +0300</pubDate><content:encoded><![CDATA[<h1>What is the “Swift Language Version” Xcode setting for?</h1><p>Prior to Swift 4, the version of the compiler and the language were one and the same. But since Swift 4, the compiler can run in a compatibility mode for previous Swift versions. check more info on <a href="https://swift.org/blog/swift-4-0-released/">compatibility modes</a> in the Swift 4.0 release notes. The Xcode build setting <code>SWIFT_VERSION</code> set's the compiler flag <code>-swift-version</code> which is the language mode. From the swift compiler print out below this parameter only changes how the input is interpreted.</p><blockquote><p>-swift-version &lt;vers&gt; Interpret input according to a specific Swift language version number</p></blockquote><p>Thus When you select Swift Language Version to 4.2, this does not mean use Swift 4.2 compiler. The compiler version will still be 5.1.3, the Swift Language Version setting instructs the compiler to run in Swift 4.2 compatibility mode. The compatibility mode means you may not need to modify your swift 4.2 code to use the new version of the compiler. Because the compiler running in compatibility mode allows Swift version 4.2 code to compile and run alongside code from version 5 and later.</p><img src="https://i.stack.imgur.com/r5Ofc.jpg"/><p>The Swift 5 compiler with compatibility mode can compile code written with either <strong><em>Swift 4 syntax</em></strong>, <strong>Swift 4.2 syntax</strong>, or <strong>Swift 5 syntax</strong>.</p><p>Here is a code example, create a file test.swift with code below:</p><pre><code><span class="swift-comment">//code written before siwft 5</span>
<span class="swift-keyword">let</span> firstName = <span class="swift-string">"michael jackson"</span>
<span class="swift-keyword">let</span> offset = firstName.<span class="swift-property">endIndex</span>.<span class="swift-property">encodedOffset</span>

<span class="swift-comment">// Check swift version being used.</span>
<span class="swift-preprocessing">#if swift(&gt;=5.2)</span>
<span class="swift-call">print</span>(<span class="swift-string">"Hello, Swift 5.2"</span>)

<span class="swift-preprocessing">#elseif swift(&gt;=5.1)</span>
<span class="swift-call">print</span>(<span class="swift-string">"Hello, Swift 5.1"</span>)

<span class="swift-preprocessing">#elseif swift(&gt;=5.0)</span>
<span class="swift-call">print</span>(<span class="swift-string">"Hello, Swift 5.0"</span>)

<span class="swift-preprocessing">#elseif swift(&gt;=4.2)</span>
<span class="swift-call">print</span>(<span class="swift-string">"Hello, Swift 4.2"</span>)

<span class="swift-preprocessing">#elseif swift(&gt;=4.1)</span>
<span class="swift-call">print</span>(<span class="swift-string">"Hello, Swift 4.1"</span>)

<span class="swift-preprocessing">#elseif swift(&gt;=4.0)</span>
<span class="swift-call">print</span>(<span class="swift-string">"Hello, Swift 4.0"</span>)

<span class="swift-preprocessing">#endif</span>
</code></pre><p>suppose the above code was written before swift 5 using the swift 4 compiler this code will compile with no error's as shown below.</p><img src="https://i.stack.imgur.com/JMzuV.jpg"/><p>After swift 5 is released if you try to compile this code with Swift 5 compiler as shown below.</p><img src="https://i.stack.imgur.com/9fnOm.jpg"/><p>You will get the warning shown above since <code>encodedOffset</code> is deprecated in swift 5. You could downgrade and use the swift 4 compiler or you can use the Swift 5 compiler in compatibility mode with the compiler flag -swift-version as shown below.</p><img src="https://i.stack.imgur.com/IU9nI.jpg"/><p>It's important to note that <strong>Swift 4 compiler</strong>, and the <strong>Swift 5 compiler in Swift-4 compatibility mode</strong> are not the same thing. New swift 5 language features are normally available to the swift 5 compiler running compatibility mode. This allows developers to use the new features even when they can't upgrade to swift 5. The new Swift 5 features will not be available to the <strong>Swift 4 compiler</strong>.</p>]]></content:encoded></item></channel></rss>